\subsection{Merkmale klassischer Softwareentwicklung}
% \addcontentsline{toc}{subsection}{Merkmale klassischer Softwareentwicklung}
\label{Merkmale klassischer Softwareentwicklung}
Ausgehend von den generischen Softwareentwicklungsmodellen ist diesen klassischen Entwicklungsmodellen gemeinsam, dass sie Software als etwas betrachten, dass \textit{fertiggestellt} werden kann. D.h. die Prozesse auf Basis der genannten Entwicklunsgmodelle finden nach einer endlichen Anzahl Iterationen ein Ende. In der Praxis ist dies meist bei Abschluss und Abnahme eines Projektes der Fall. Die Software bietet zu diesem Zeitpunkt einen definierten und getesteten Funktionsumfang. Dieser muss nicht zwangsläufig vollständig der Ausgangsspezifikation aus der ersten Anforderungsdefinition entsprechen \cite[Kap. 9.2]{Manfred_Marko_PM_2013}. Entscheidend ist jedoch, dass dieser Zyklus endlich ist. Dies impliziert zwei Dinge: 
\begin{enumerate}
	\item Die Anforderungen sind endlich
	\item Die Phasen können ohne grundsätzliche Änderungen an der Ausgangslage durchlaufen werden
\end{enumerate}
Diese Aussagen gehen auf den von Royce spezifizierten Ablauf (\glqq{}STEP 1: PROGRAM DESIGN COMES FIRST - STEP2: DOCUMENT THE DESIGN\grqq{}, \cite{royce1987managing}) zurück und spiegeln die Art der Softwarentwicklung zur Zeit der Entstehung dieser Entwicklungsmodelle wieder (1987 Wasserfallmodell \cite{royce1987managing}, 1988 Spiralmodell \cite{boehm_spiral_1988}).
Dementsprechend haben diese Modelle einen Fokus auf Anforderungsaufnahme (\gls{Requirements Engineering}) und Analyse vor Beginn der Umsetzung in Quellcode, direkt verbunden mit entsprechenden Tests und Dokumentation. Diese Verknüpfung von Teilschritten auf einer Ebene als ein Paar ist ein von Boehm im Spiralmodell angedeuteter Ansatz (Vgl. \cite[Abb. 2]{boehm_spiral_1988}, phasenübergreifende, zusammenhänge Schritte stehen parallel zueinander). Dieser hat bis heute seine Relevanz behalten (z.B. im V-Modell XT \cite{noauthor_bundesregierung_nodate}). Diese monolithische Vorgehensweise ist damit besonders geeignet für Fälle und Umgebungen, die planbar oder nur wenig veränderlich sind. Je besser Anforderungen und spätere Umsetzung modelliert werden können, desto einfacher sind nachher Implementierung und Tests. Dies wiederum bedeutet, das weniger Modelliterationen bis zum Abschluss eines Projektes notwendig sind.
Diese Vorgehensweisen kommen jedoch in den extrem kurzlebigen Lebenszyklen moderner Software jedoch an ihre Grenzen. Der jährlich veröffentlichte CHAOS Report der Standish Group gibt in diesem Kontext einen guten Eindruck der entscheidenden Herausforderungen klassischer linearer Softwareentwicklung. Schon in der ersten Ausgabe von 1994 / 1995 \cite{noauthor_standish_1995} wurden unvollständige, wechselnde Anforderungen sowie Spezifikationen als zwei der drei wesentlichen Faktoren für das Fehlschlagen von Softwareprojekten genannt  \cite[S. 4]{noauthor_standish_1995}.
Die klassischen Modelle können mit diesen Herausforderungen nicht gut Schritt halten.